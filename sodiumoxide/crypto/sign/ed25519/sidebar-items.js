initSidebarItems({"constant":[["PUBLICKEYBYTES","Number of bytes in a `PublicKey`."],["SECRETKEYBYTES","Number of bytes in a `SecretKey`."],["SEEDBYTES","Number of bytes in a `Seed`."],["SIGNATUREBYTES","Number of bytes in a `Signature`."]],"fn":[["gen_keypair","`gen_keypair()` randomly generates a secret key and a corresponding public key."],["keypair_from_seed","`keypair_from_seed()` computes a secret key and a corresponding public key from a `Seed`."],["sign","`sign()` signs a message `m` using the signer’s secret key `sk`. `sign()` returns the resulting signed message `sm`."],["sign_detached","`sign_detached()` signs a message `m` using the signer’s secret key `sk`. `sign_detached()` returns the resulting signature `sig`."],["to_curve25519_pk","Converts a ed25519 [PublicKey]  into a curve25519 [box_::PublicKey]"],["to_curve25519_sk","Converts an ed25519 [SecretKey] into a curve25519 [box_::SecretKey]"],["verify","`verify()` verifies the signature in `sm` using the signer’s public key `pk`. `verify()` returns the message `Ok(m)`. If the signature fails verification, `verify()` returns `Err(())`."],["verify_detached","`verify_detached()` verifies the signature in `sig` against the message `m` and the signer’s public key `pk`. `verify_detached()` returns true if the signature is valid, false otherwise."]],"struct":[["Error","Signature errors."],["PublicKey","`PublicKey` for signatures"],["SecretKey","`SecretKey` for signatures"],["Seed","`Seed` that can be used for keypair generation"],["Signature","Ed25519 signature."],["State","State for multi-part (streaming) computation of signature."]],"trait":[["Signer","Sign the provided message bytestring using `Self` (e.g. a cryptographic key or connection to an HSM), returning a digital signature."],["Verifier","Verify the provided message bytestring using `Self` (e.g. a public key)"]]});